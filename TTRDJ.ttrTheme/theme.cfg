function rgb(rgbValue)
rgbValue[1] = rgbValue[1] / 255;
rgbValue[2] = rgbValue[2] / 255;
rgbValue[3] = rgbValue[3] / 255;
return rgbValue;
end

-- Background movement types
Disable = 0;
ScaleXY = 1;
WashingMachine = 2;
AlphaOscillate = 3;
ScrollRotate = 5;
--

-- Background movement types
layers = {"Game/Background0", 
"Game/Background", 
"Game/Background2", 
"Game/Columns", 
"Game/Columns2", 
"Game/FeedbackLayer", 
"Game/Score"};

--!
local leftCurveXPoints = {
{295, 53},
{276, 55},
{258, 58},
{241, 62},
{225, 66},
{210, 70},
{196, 74},
{183, 78},
{171, 83},
{160, 87},
{149, 95},
{144, 103},
{139, 110},
{135, 125},
{133, 138},
{131, 152},
{129, 165},
{127, 179},
{124, 192},
{121, 206},
{117, 220},
{114, 233},
{111, 245},
{108, 257},
{104, 272},
{99, 287},
{95, 300},
{91, 314},
{86, 327},
{82, 341},
{76, 357},
{71, 373},
{67, 386},
{62, 400},
{58, 411},
{54, 422}
};
--!
local middleCurveXPoints = {
{160, 53},
{160, 55},
{160, 58},
{160, 62},
{160, 66},
{160, 70},
{160, 74},
{160, 78},
{160, 83},
{160, 87},
{160, 95},
{160, 103},
{160, 110},
{160, 125},
{160, 138},
{160, 152},
{160, 165},
{160, 179},
{160, 192},
{160, 206},
{160, 220},
{160, 233},
{160, 245},
{160, 257},
{160, 272},
{160, 287},
{160, 300},
{160, 314},
{160, 327},
{160, 341},
{160, 357},
{160, 373},
{160, 386},
{160, 400},
{160, 411},
{160, 422}
};
--!
local rightCurveXPoints = {
{25, 53},
{44, 55},
{62, 58},
{79, 62},
{95, 66},
{110, 70},
{124, 74},
{137, 78},
{149, 83},
{160, 87},
{171, 95},
{176, 103},
{181, 110},
{185, 125},
{187, 138},
{189, 152},
{191, 165},
{193, 179},
{196, 192},
{199, 206},
{203, 220},
{206, 233},
{209, 245},
{212, 257},
{216, 272},
{221, 287},
{225, 300},
{229, 314},
{234, 327},
{238, 341},
{244, 357},
{249, 373},
{253, 386},
{258, 400},
{262, 411},
{266, 422}
};
--!
 BackgroundBlendMode = SourcePlusOneMinusSourceAlphaBlend;
--!
 timeWindow = 1.65;
--!
 tapHoldBlendMode = SourcePlusOneMinusSourceAlphaBlend;
--!
 tapperBlendMode = SourcePlusOneMinusSourceAlphaBlend;
--!
 tapperScaleStart = .00;
--!
 tapperScaleEnd = .75;
--!
 splashBlendMode = AdditiveBlend;
--!
 disableColors = 1;
--!
 niR = 0.000000;
--!
 niG = 0.000000;
--!
 niB = 0.000000;
--!
 npR = 0.000000;
--!
 npG = 0.000000;
--!
 npB = 0.000000;
--!
 ngR = 0.000000;
--!
 ngG = 0.000000;
--!
 ngB = 0.000000;
--!
 noR = 0.000000;
--!
 noG = 0.000000;
--!
 noB = 0.000000;
--!
 nbR = 0.000000;
--!
 nbG = 0.000000;
--!
 nbB = 0.000000;
--!
 nmR = 0.000000;
--!
 nmG = 0.000000;
--!
 nmB = 0.000000;
--!
 riR = 0.000000;
--!
 riG = 0.000000;
--!
 riB = 0.000000;
--!
 rpR = 0.000000;
--!
 rpG = 0.000000;
--!
 rpB = 0.000000;
--!
 rgR = 0.000000;
--!
 rgG = 0.000000;
--!
 rgB = 0.000000;
--!
 roR = 0.000000;
--!
 roG = 0.000000;
--!
 roB = 0.000000;
--!
 rbR = 0.000000;
--!
 rbG = 0.000000;
--!
 rbB = 0.000000;
--!
 rmR = 0.000000;
--!
 rmG = 0.000000;
--!
 rmB = 0.000000;
--!
 primarySpinnerMovementType = ScrollRotate;
--!
 primaryDisableOnSlowDevice = 0;
--!
 primaryImage = "space.jpg";
--!
 primarySpinnerBlendMode = SourcePlusOneMinusSourceAlphaBlend;
--!
 primaryLayer = 0;
--!
 primaryPositionX = 160;
--!
 primaryPositionY = 240;
--!
 primaryScaleX = 1.18;
--!
 primaryScaleY = 1.18;
--!
 primaryAlphaInitial = 1;
--!
 primaryAlphaNormal = 1;
--!
 primaryAlphaRevenge = 0;
--!
 primaryAlphaFadeTime = 0;
--!
 primarySpinnerXScrollSpeed = 0.009;
--!
 primarySpinnerYScrollSpeed = 0.018;
--!
 primarySpinnerRotationSpeed = 1;
--!
 primaryAmplitude = 0;
--!
 primaryFrequency = 0;
--!
 primaryPhase = 0;
--!
 primaryOffset = 0;
--!
 primaryAmplitudeY = 0;
--!
 primaryFrequencyY = 0;
--!
 primaryPhaseY = 0;
--!
 primaryOffsetY = 0;
--!
 secondSpinnerMovementType = ScrollRotate;
--!
 secondDisableOnSlowDevice = 0;
--!
 secondImage = "space-revenge.pvrtc";
--!
 secondSpinnerBlendMode = NoBlend;
--!
 secondLayer = 0;
--!
 secondPositionX = 160;
--!
 secondPositionY = 240;
--!
 secondScaleX = 1;
--!
 secondScaleY = 1;
--!
 secondAlphaInitial = 0;
--!
 secondAlphaNormal = 0;
--!
 secondAlphaRevenge = 1;
--!
 secondAlphaFadeTime = 0;
--!
 secondSpinnerXScrollSpeed = -0.02;
--!
 secondSpinnerYScrollSpeed = 0;
--!
 secondSpinnerRotationSpeed = 0;
--!
 secondAmplitude = 0;
--!
 secondFrequency = 0;
--!
 secondPhase = 0;
--!
 secondOffset = 0;
--!
 secondAmplitudeY = 0;
--!
 secondFrequencyY = 0;
--!
 secondPhaseY = 0;
--!
 secondOffsetY = 0;
--!
 thirdSpinnerMovementType = ScrollRotate;
--!
 thirdDisableOnSlowDevice = 0;
--!
 thirdImage = "stars.pvrtc";
--!
 thirdSpinnerBlendMode = AdditiveBlend;
--!
 thirdLayer = 1;
--!
 thirdPositionX = 160;
--!
 thirdPositionY = 190;
--!
 thirdScaleX = .85;
--!
 thirdScaleY = .85;
--!
 thirdAlphaInitial = .6;
--!
 thirdAlphaNormal = .6;
--!
 thirdAlphaRevenge = 0;
--!
 thirdAlphaFadeTime = 0;
--!
 thirdSpinnerXScrollSpeed = 0.012;
--!
 thirdSpinnerYScrollSpeed = 0.026;
--!
 thirdSpinnerRotationSpeed = 2;
--!
 thirdAmplitude = 0;
--!
 thirdFrequency = 0;
--!
 thirdPhase = 0;
--!
 thirdOffset = 0;
--!
 thirdAmplitudeY = 0;
--!
 thirdFrequencyY = 0;
--!
 thirdPhaseY = 0;
--!
 thirdOffsetY = 0;
--!
 fourthSpinnerMovementType = Disable;
--!
 fourthDisableOnSlowDevice = 0;
--!
 fourthImage = "stars.pvrtc";
--!
 fourthSpinnerBlendMode = AdditiveBlend;
--!
 fourthLayer = 1;
--!
 fourthPositionX = 160;
--!
 fourthPositionY = 240;
--!
 fourthScaleX = 1;
--!
 fourthScaleY = 1;
--!
 fourthAlphaInitial = 0;
--!
 fourthAlphaNormal = 0;
--!
 fourthAlphaRevenge = 1;
--!
 fourthAlphaFadeTime = .15;
--!
 fourthSpinnerXScrollSpeed = 0;
--!
 fourthSpinnerYScrollSpeed = 0;
--!
 fourthSpinnerRotationSpeed = 0;
--!
 fourthAmplitude = 1;
--!
 fourthFrequency = 5;
--!
 fourthPhase = 0;
--!
 fourthOffset = 0;
--!
 fourthAmplitudeY = 0;
--!
 fourthFrequencyY = 0;
--!
 fourthPhaseY = 0;
--!
 fourthOffsetY = 0;
--!
 fifthSpinnerMovementType = Disable;
--!
 fifthDisableOnSlowDevice = 0;
--!
 fifthImage = "stars.pvrtc";
--!
 fifthSpinnerBlendMode = AdditiveBlend;
--!
 fifthLayer = 1;
--!
 fifthPositionX = 160;
--!
 fifthPositionY = 240;
--!
 fifthScaleX = 1;
--!
 fifthScaleY = 1;
--!
 fifthAlphaInitial = 1;
--!
 fifthAlphaNormal = 1;
--!
 fifthAlphaRevenge = 1;
--!
 fifthAlphaFadeTime = 0;
--!
 fifthSpinnerXScrollSpeed = 0;
--!
 fifthSpinnerYScrollSpeed = 0;
--!
 fifthSpinnerRotationSpeed = 0;
--!
 fifthAmplitude = .5;
--!
 fifthFrequency = 10;
--!
 fifthPhase = 0;
--!
 fifthOffset = .45;
--!
 fifthAmplitudeY = .25;
--!
 fifthFrequencyY = 10;
--!
 fifthPhaseY = 0;
--!
 fifthOffsetY = .55;
--!@




initialBackgroundColor = {niR, niG, niB};
initialRevengeBackgroundColor = {riR, riG, riB};
backgroundColors = {     
    missColor = {.1, .1, .1},
    badColor = {0.984, 0, 0.030},
    okColor = {0.991, 0.623, 0.039},
    goodColor = {0.129, 0.934, 0.999},
    perfectColor = {0.139, 1, 0.035},
};
revengeBackgroundColors = {
	missColor = {rmR, rmG, rmB},
    badColor = {rbR, rbG, rbB},
    okColor = {roR, roG, roB},
    goodColor = {rgR, rgG, rgB},
    perfectColor = {rpR, rpG, rpB}
};

trackColors = {
	twoX = {255/255, 233/255, 102/255},
	threeX = {255/255, 143/255, 169/255},
	fourX = {178/255, 158/255, 255/255},
	eightX2 = {195/255, 220/255, 251/255},
	eightX = {168/255, 202/255, 255/255},
	sixteenX = {213/255, 192/255, 255/255}
};

-------------------------------------------------------------------------------------------------------------------
-- SPECIAL THEME EVENT FUNCTIONS
-------------------------------------------------------------------------------------------------------------------
function theme_initialize()
    game.useDefaultFeedback = true;



    theme_initShaders();
    theme_createObjects();
	
    
	player = game:firstPlayer();
	
	player:setSplashScaleFromArray({1,1,1});
	
	setTimeout(0, "registerFeedbackSettings", nil);
end

function registerFeedbackSettings()
	game:setFeedbackSettings{
	   pathColors = backgroundColors
  	};

end

function theme_postHudInitialize()

	--REMOVEING OLD HUD STUFFS
	hudProgressball:removeFromParent();
	hudOverlay:removeFromParent();
	
end



-----------------------------------
function theme_initShaders()
    revengeShaderWithTextures("background.png", "background-revenge.png", "background", 3, BackgroundBlendMode);
	
    revengeShaderWithTextureRegions("parts.png", {0*0,0,64,64}, {3*64, 0, 64, 64}, "left_tap", 7, tapperBlendMode);
    revengeShaderWithTextureRegions("parts.png", {1*64,0,64,64}, {4*64, 0, 64, 64},"middle_tap", 7, tapperBlendMode);
    revengeShaderWithTextureRegions("parts.png", {2*64,0,64,64}, {5*64, 0, 64, 64}, "right_tap", 7, tapperBlendMode);
    simpleShaderWithTextureRegion("parts.png", {6*64,0,64,64}, "special_tap", 7, tapperBlendMode, "nearest", "nearest");
	
    revengeShaderWithTextureRegions("parts.png", {0*64,64,64,64}, {3*64,64,64,64}, "shake_left", 7, tapperBlendMode);
    revengeShaderWithTextureRegions("parts.png", {1*64,64,64,64}, {4*64,64,64,64}, "shake_updown", 7, tapperBlendMode);
    revengeShaderWithTextureRegions("parts.png", {2*64,64,64,64}, {5*64,64,64,64}, "shake_right", 7, tapperBlendMode);
	
    simpleShaderWithTextureRegion("parts.png", {0*64, 2*64, 128, 128}, "tap_splash_red", 100, splashBlendMode );	
    simpleShaderWithTextureRegion("parts.png", {2*64, 2*64, 128, 128}, "tap_splash_green", 100, splashBlendMode );	
    simpleShaderWithTextureRegion("parts.png", {4*64, 2*64, 128, 128}, "tap_splash_blue", 100, splashBlendMode );
	
end

-----------------------------------
function theme_createObjects()
    game:addScene{ name = "Game" };
	game:addLayer{ name = "White", scenePath = "Game"};
	game:addLayer{ name = "Background0", scenePath = "Game"};
	game:addLayer{ name = "WavesLayer", scenePath = "Game", renderingMode = "3d", zNear = 1, zFar = 8500, fieldOfView = 40, rotation = {14, 0, 90} };
	game:addLayer{ name = "revengeLayer", scenePath = "Game", renderingMode = "3d", zNear = 1, zFar = 8500, fieldOfView = 80, rotation = {0, 0, 0} };
	game:addLayer{ name = "Background", scenePath = "Game"};
	game:addLayer{ name = "Background2", scenePath = "Game"};
	game:addLayer{ name = "Columns", scenePath = "Game" };
	game:addLayer{ name = "Columns2", scenePath = "Game" };
	game:addLayer{ name = "Score", scenePath = "Game"};
	game:addLayer{ name = "FeedbackLayer", scenePath = "Game" };

	
end

-----------------------------------
function theme_initOnePlayerMode()
	   
	game:addSprite{
		scenePath = "Game/Background", shader = "background", position = {160, 240, 0}, scale = {322/320, 482/480, 1}
	};
	
	theme_initSpinnerEffectSprite();
	
-- TIME WINDOW CHANGES PER LEVEL

	if(difficultyLevel <= 1) then timeWindow = 2.70 
	elseif(difficultyLevel == 2) then timeWindow = 2.15 
	elseif(difficultyLevel == 3) then timeWindow = 1.80
	elseif(difficultyLevel == 4) then timeWindow = 1.40
	end
	
-- NINJA ASSASSIN SAYS STOP LOOKING AT MY CODE YOU HACKER - Ernest
	
	eight = 0;
	spaceAura = 0;
	
-- HUD REPLACEMENT
	
	simpleShaderWithTextureRegion("HUD.png", {0, 0, 322, 46}, "hudOverlay", -10, AlphaBlend, "nearest", "nearest");
	simpleShaderWithTextureRegion("progressBall.png", {0, 0, 6, 6}, "hudProgressBall", 100, AlphaBlend, "nearest", "nearest");
	simpleShaderWithTextureRegion("weaponZone.png", {0, 0, 64, 64}, "hud-weaponzone", -1, AlphaBlend, "nearest", "nearest");
	
	hudOverlay2 = game:addSprite {
		scenePath = "Game/Score", shader = "hudOverlay",
		name = "hudOverlay", position = {160, 22, 0},
		size = {322, 46}
	};
	
	local progressVelocity = (181 * screenWidth / 320) / game.audioPlayer.playbackTotal;
	hudProgressBall2 = game:addSprite {
		scenePath = "Game/Score", shader = "hudProgressBall",
		name = "hudProgressBall", position = {71, 37, 0}, velocity = {progressVelocity, 0, 0},
		size = {6, 6}
	}
	
    simpleShaderWithTextureRegion("HUD-meters.png", {32*0, 0, 32, 128}, "hud-mult-1x", 100, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("HUD-meters.png", {32*1, 0, 32, 128}, "hud-mult-2x", 100, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("HUD-meters.png", {32*2, 0, 32, 128}, "hud-mult-3x", 100, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("HUD-meters.png", {32*3, 0, 32, 128}, "hud-mult-4x", 100, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("HUD-meters.png", {32*4, 0, 32, 128}, "hud-mult-8x", 100, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("HUD-meters.png", {32*5, 0, 32, 128}, "hud-mult-16x", 100, AlphaBlend, "nearest", "nearest");

simpleShaderWithTextureRegion("multipliers.png", {0*128, 0*128, 128, 128}, "2x_multiplier", 200, AlphaBlend);
    simpleShaderWithTextureRegion("multipliers.png", {1*128, 0*128, 128, 128}, "3x_multiplier", 200, AlphaBlend);
    simpleShaderWithTextureRegion("multipliers.png", {2*128, 0*128, 128, 128}, "4x_multiplier", 200, AlphaBlend);
    simpleShaderWithTextureRegion("multipliers.png", {3*128, 0*128, 128, 128}, "revenge_available", 200, AlphaBlend);
    simpleShaderWithTextureRegion("multipliers.png", {3*128, 1*128, 128, 128}, "hud-take16x", 200, AlphaBlend);
	
	hudAccuracyShaders = {
		simpleShaderWithTextureRegion("HUD-meters.png", {32*0, 128, 32, 128}, "hud-accuracy-miss", 100, AlphaBlend, "nearest", "nearest"),
		simpleShaderWithTextureRegion("HUD-meters.png", {32*1, 128, 32, 128}, "hud-accuracy-poor-early", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*2, 128, 32, 128}, "hud-accuracy-ok-early", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*3, 128, 32, 128}, "hud-accuracy-good-early", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*4, 128, 32, 128}, "hud-accuracy-perfect", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*5, 128, 32, 128}, "hud-accuracy-good-late", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*6, 128, 32, 128}, "hud-accuracy-ok-late", 100, AlphaBlend, "nearest", "nearest"),
        simpleShaderWithTextureRegion("HUD-meters.png", {32*7, 128, 32, 128}, "hud-accuracy-poor-late", 100, AlphaBlend, "nearest", "nearest"),
    };
	
	simpleShaderWithTextureRegion("HUD-online.jpg", {0, 0, 40, 33}, "hud-overlay-online", -9, AlphaBlend, "nearest", "nearest");    
	
	simpleShaderWithTextureRegion("textFeedback.png", {0, 32, 64, 32}, "miss_image", 200, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("textFeedback.png", {0,  0, 64, 32}, "great_image", 200, AlphaBlend, "nearest", "nearest");
    simpleShaderWithTextureRegion("textFeedback.png", {0, 64, 64, 32}, "hud-explain-weaponzone", -2, AlphaBlend, "nearest", "nearest");
	simpleShaderWithTextureRegion("textFeedback.png", {0, 64, 64, 32}, "hud-explain-weaponwait", 100000, AlphaBlend );
	simpleShaderWithTextureRegion("powerup-16x.png", {0, 0, 64, 64}, "item-TTRSpecialItem16xMode", 100, AlphaBlend);


-- OPENING DOORS 298

	simpleShaderWithTextureRegion("doorTop.jpg", {0, 0, 322, 239}, "doorTop", 240, SourcePlusOneMinusSourceAlphaBlend);
	simpleShaderWithTextureRegion("doorBottom.jpg", {0, 0, 322, 239}, "doorBottom", 235, NoBlend);
	simpleShaderWithTextureRegion("fadeIn.jpg", {0, 0, 341, 512}, "fadeIn", 225, AlphaBlend);
	
	doorTop = game:addSprite {
		scenePath = "Game/FeedbackLayer", shader = "doorTop",
		name = "doorTop", position = {160, 118.5, 0},
		velocity = {0, -90, 0}, acceleration = {0, -330, 0}, lifetime = 1.5
	};
	
	doorBottom = game:addSprite {
		scenePath = "Game/FeedbackLayer", shader = "doorBottom",
		name = "doorBottom", position = {160, 359.5, 0},
		velocity = {0, 90, 0}, acceleration = {0, 330, 0}, lifetime = 1.5
	};
	
	fadeInIntro();
	
-- FEEDBACK RINGS!!!

    	simpleShaderWithTextureRegion("parts.png",{0*128, 256, 128, 128}, "feedbackringL", 6, AdditiveBlend);
    	simpleShaderWithTextureRegion("parts.png",{1*128, 256, 128, 128}, "feedbackringC", 6, AdditiveBlend);
    	simpleShaderWithTextureRegion("parts.png",{2*128, 256, 128, 128}, "feedbackringR", 6, AdditiveBlend);
    	game:addSprite {
    	    scenePath = "Game/Columns", shader = "feedbackringL",
    	    name = "leftFeedbackSprite", position = {67, 420, 0}, color = backgroundColors["missColor"],
    	};
    	game:addSprite {
    	    scenePath = "Game/Columns", shader = "feedbackringC",
    	    name = "centerFeedbackSprite", position = {160, 420, 0}, color = backgroundColors["missColor"],
    	};
    	rightFeedbackSprite = game:addSprite {
    	    scenePath = "Game/Columns", shader = "feedbackringR",
    	    name = "rightFeedbackSprite", position = {320-67, 420, 0}, color = backgroundColors["missColor"],
    	};
	
		
-- PARTICLEZ!!!!

	simpleShaderWithTextureRegion("triangles-revenge.jpg", {0, 0, 512, 512}, "triangles", 120, AdditiveBlend);
	--simpleShaderWithTextureRegion("blackSwirl.jpg", {0, 0, 512, 512}, "blackSwirl", 120, AdditiveBlend);
	--simpleShaderWithTextureRegion("blackDebris.png", {0, 0, 256, 256}, "blackDebris", 130, AlphaBlend);
    --simpleShaderWithTextureRegion("revBurst.jpg", {0, 0, 256, 256}, "revBurst", 120, AdditiveBlend);
    simpleShaderWithTextureRegion("spaceParticles.png", {0, 0, 256, 256}, "spaceParticles1", 120, AdditiveBlend);
    simpleShaderWithTextureRegion("spaceParticles.png", {256, 0, 256, 256}, "spaceParticles2", 120, AdditiveBlend);
    simpleShaderWithTextureRegion("comet.jpg", {0, 0, 128, 32}, "comet", 120, AdditiveBlend);
	addParticles();
	
-- TAP-HOLD GRAPHICS!!!
		
    simpleShaderWithTextureRegion("parts.png", {6*64, 128, 64, 4*64}, "left_hold_shader", 6, SourcePlusOneMinusSourceAlphaBlend);
    simpleShaderWithTextureRegion("parts.png",{6*64, 128, 64, 4*64}, "center_hold_shader", 6, SourcePlusOneMinusSourceAlphaBlend);
    simpleShaderWithTextureRegion("parts.png", {6*64, 128, 64, 4*64}, "right_hold_shader", 6, SourcePlusOneMinusSourceAlphaBlend);
    simpleShaderWithTextureRegion("parts.png",{7*64, 128, 64, 4*64},  "left_hold_active_shader", 6, SourcePlusOneMinusSourceAlphaBlend);
    simpleShaderWithTextureRegion("parts.png",{7*64, 128, 64, 4*64},  "center_hold_active_shader", 6, SourcePlusOneMinusSourceAlphaBlend);
    simpleShaderWithTextureRegion("parts.png",{7*64, 128, 64, 4*64},  "right_hold_active_shader", 6, SourcePlusOneMinusSourceAlphaBlend);

-- REVENGE EFFECTS AND STUFFS

    scrollingShaderWithTexture( "waves-revenge.jpg", "WavesL", 1, AdditiveBlend, 0, -0.15, 1);
    scrollingShaderWithTexture( "waves-revenge.jpg", "WavesR", 1, AdditiveBlend, 0, 0.15, 1);
    scrollingShaderWithTexture( "scroller-revenge.jpg", "Atmosphere", 1, AdditiveBlend, -.02, 0, 1);
	
    WavesL = game:addSprite{ 
        name = "WavesL", scenePath = "Game/WavesLayer", 
        shader = "WavesL",
		alpha = 0,
        position = {-5, 40, 0}, size = {128, 256}, scale = {1.5, 3, 1}, rotation = {-55, 0, 0},
    };
	
    WavesR = game:addSprite{ 
        name = "WavesR", scenePath = "Game/WavesLayer", 
        shader = "WavesR",
		alpha = 0,
        position = {-5, 75, -200}, size = {128, 256}, scale = {1.5, 3, 1}, rotation = {55, 0, 0},
    };

    Atmosphere = game:addSprite{ 
        name = "Atmosphere", scenePath = "Game/WavesLayer", 
        shader = "Atmosphere",
		alpha = 1,
        position = {15, 120, 0}, size = {512, 512}, scale = {1, 1, 1}, rotation = {20, 0, 0},
    };

-- 16X EFFECTS. HEY THAT RHYMES.
	
	
    --scrollingShaderWithTexture( "corridor-revenge.jpg", "corridor", 1, AdditiveBlend, -0.5, 0, 1);
    scrollingShaderWithTexture( "smoke16x.jpg", "zoom", 1, AdditiveBlend, 0, .3, 1);
	
    --corridorTop = game:addSprite{ 
    --    name = "corridorTop", scenePath = "Game/revengeLayer", 
    --    shader = "corridor",
	--	alpha = 0,
    --    position = {60, -22, -50}, size = {512, 512}, scale = {0.0, 0.0, 1}, rotation = {-44, 0, 0},
    --};
	
    --corridorBottom = game:addSprite{ 
    --    name = "corridorBottom", scenePath = "Game/revengeLayer", 
    --    shader = "corridor",
	--	alpha = 0,
    --    position = {60, 195, -50}, size = {512, 512}, scale = {0.0, 0.0, 1}, rotation = {-75, 0, 0},
    --};
	
    zoomTop = game:addSprite{ 
        name = "zoomTop", scenePath = "Game/revengeLayer", 
        shader = "zoom",
		alpha = 0,
        position = {60, -25, -50}, size = {512, 512}, scale = {0.0, 0.0, 1}, rotation = {-44, 0, 0},
    };
	
    zoomBottom = game:addSprite{ 
        name = "zoomBottom", scenePath = "Game/revengeLayer", 
        shader = "zoom",
		alpha = 0,
        position = {60, 200, -50}, size = {512, 512}, scale = {0.0, 0.0, 1}, rotation = {-75, 0, 0},
    };
	
	revengeWave = game:addSprite {
		scenePath = "Game/Background2", shader = "WavesL",
		name = "revengeWave", position = {160, 160, 0},
		alpha = 0, scale = {0.0, 0.0, 1}, rotation = {0, 0, 90};
	};


    
    local origins = { {leftCurveXPoints[1][1], leftCurveXPoints[1][2], 0}, {middleCurveXPoints[1][1], middleCurveXPoints[1][2], 0}, {rightCurveXPoints[1][1], rightCurveXPoints[1][2], 0} };
    local destinations = { {leftCurveXPoints[#leftCurveXPoints][1], leftCurveXPoints[#leftCurveXPoints][2], 0}, {middleCurveXPoints[#middleCurveXPoints][1], middleCurveXPoints[#middleCurveXPoints][2], 0}, {rightCurveXPoints[#rightCurveXPoints][1], rightCurveXPoints[#rightCurveXPoints][2], 0} };
   -- local alphaCurve = { pathPoints = { {0, 0}, {0.1, 0}, {0.15, 1}, {1, 1} } };
	local alphaCurve = { pathPoints = { {0.1, 0}, {0.1, 0}, {0.15, 1}, {1, 1} } };
    local scaleCurve = { targetValue = tapperScaleEnd, startValue = tapperScaleStart, curveType = "EaseInSin" };



	 local leftyPoints = {};
    local leftCurveXp = {};
	 
	 table.insert(leftCurveXp, {0, leftCurveXPoints[1][1]});
	 table.insert(leftyPoints, {0, leftCurveXPoints[1][2]});
	 
    for i,pt in ipairs(leftCurveXPoints) do
        local p = (i) / (#leftCurveXPoints);
        
        table.insert(leftCurveXp, {p, leftCurveXPoints[i][1]});
        table.insert(leftyPoints, {p, leftCurveXPoints[i][2]});
    end
	 local leftyCurve = { pathPoints = leftyPoints };
    local leftCurveX = { pathPoints = leftCurveXp };
--------
	 local middleyPoints = {};
    local middleCurveXp = {};
	 
		table.insert(middleCurveXp, {0, middleCurveXPoints[1][1]});
		table.insert(middleyPoints, {0, middleCurveXPoints[1][2]});

    for i,pt in ipairs(middleCurveXPoints) do
        local p = (i) / (#middleCurveXPoints);
        table.insert(middleCurveXp, {p, middleCurveXPoints[i][1]});
        table.insert(middleyPoints, {p, middleCurveXPoints[i][2]});
    end
	 local middleyCurve = { pathPoints = middleyPoints };
    local middleCurveX = { pathPoints = middleCurveXp };
---------
	 local rightyPoints = {};
	 local rightCurveXp = {};
	 
	 table.insert(rightCurveXp, {0, rightCurveXPoints[1][1]});
	 table.insert(rightyPoints, {0, rightCurveXPoints[1][2]});
	 
	 for i,pt in ipairs(rightCurveXPoints) do
        local p = (i) / (#rightCurveXPoints);
		  
        table.insert(rightCurveXp, {p, rightCurveXPoints[i][1]});
        table.insert(rightyPoints, {p, rightCurveXPoints[i][2]});
    end
	 local rightyCurve = { pathPoints = rightyPoints };
    local rightCurveX = { pathPoints = rightCurveXp };
--------

	 
    
    -- Columns
    leftTapCol = game:addColumn{	--Left column, taps
	   useSmoothTapAndHoldTrails = false,
	   startPosition = origins[1], 
	   endPosition = destinations[1], 
	   positionXCurve = leftCurveX,
		positionYCurve = leftyCurve,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "left_tap", 
	   tapHoldShader = "left_hold_shader", 
	   tapHoldActiveShader = "left_hold_active_shader", 
	   tapHoldEmitFrequency = 0.13,
	   timeWindow = timeWindow,
	   claimedNote = 60, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000,
	   additionalClaimedNoteWhenShakesDisabled = 61,
	   scenePath = "Game/Columns"
	   };
		leftTapCol.colorChangeSpritePath = "Game/Columns/leftFeedbackSprite";
    midTapCol = game:addColumn{	--Middle column, taps
	   useSmoothTapAndHoldTrails = false,
	   startPosition = origins[2], 
	   endPosition = destinations[2], 
	   positionYCurve = middleyCurve,
		positionXCurve = middleCurveX,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "middle_tap", 
	   tapHoldShader = "center_hold_shader", 
	   tapHoldActiveShader = "center_hold_active_shader", 
	   tapHoldEmitFrequency = 0.13,
	   timeWindow = timeWindow,
	   claimedNote = 62, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000,
	   additionalClaimedNoteWhenShakesDisabled = 65,
	   scenePath = "Game/Columns"
	   };
		midTapCol.colorChangeSpritePath = "Game/Columns/centerFeedbackSprite";
    rightTapCol = game:addColumn{	--Right column, taps
	   useSmoothTapAndHoldTrails = false,
	   startPosition = origins[3], 
	   endPosition = destinations[3], 
	   positionXCurve = rightCurveX,
	   positionYCurve = rightyCurve,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "right_tap", 
	   tapHoldShader = "right_hold_shader", 
	   tapHoldActiveShader = "right_hold_active_shader", 
	   tapHoldEmitFrequency = 0.13,
	   timeWindow = timeWindow,
	   claimedNote = 64, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000,
	   additionalClaimedNoteWhenShakesDisabled = 63,
	   scenePath = "Game/Columns"
	   };
		rightTapCol.colorChangeSpritePath = "Game/Columns/rightFeedbackSprite";
	   
    leftShakeCol = game:addColumn{	--Left column, shakes
	   startPosition = origins[1], 
	   endPosition = destinations[1], 
	   positionYCurve = leftyCurve,
	   positionXCurve = leftCurveX,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "shake_left", 
	   timeWindow = timeWindow,
	   claimedNote = 61, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000, claimedNoteTapType = 1,
	   scenePath = "Game/Columns",
	   };
	   leftShakeCol.colorChangeSpritePath = "Game/Columns/leftFeedbackSprite";
    midShakeCol = game:addColumn{	--Middle column, shakes
	   startPosition = origins[2], 
	   endPosition = destinations[2], 
	   positionYCurve = middleyCurve,
	   positionXCurve = middleCurveX,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "shake_updown", 
	   timeWindow = timeWindow,
	   claimedNote = 65, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000, claimedNoteTapType = 2,
	   scenePath = "Game/Columns",
	   };
	   midShakeCol.colorChangeSpritePath = "Game/Columns/centerFeedbackSprite";
    rightShakeCol = game:addColumn{	--Right column, shakes
	   startPosition = origins[3], 
	   endPosition = destinations[3], 
	   positionYCurve = rightyCurve,
	   positionXCurve = rightCurveX,
	   startScale = { 1, 1, 1 }, 
	   endScale = { 1, 1, 1 }, 
	   scaleXCurve = scaleCurve, scaleYCurve = scaleCurve,
	   alphaCurve = alphaCurve,
	   player = 0, 
	   tapShader = "shake_right", 
	   timeWindow = timeWindow,
	   claimedNote = 63, 
	   claimedNoteWindowStartTime = 0, 
	   claimedNoteWindowDuration = 1000, claimedNoteTapType = 3,
	   scenePath = "Game/Columns",
	   };
	   rightShakeCol.colorChangeSpritePath = "Game/Columns/rightFeedbackSprite";
end

-----------------------------------
function theme_initTwoPlayerMode()
    game:addSprite{ shader = simpleShaderWithTexture( "2p/background-2p.png", "paths", 3, AdditiveBlend ), alpha = 1, 
        position = {160, 240, 0}, scenePath = "Game/Columns" };


-- TIME WINDOW CHANGES PER LEVEL

	if(difficultyLevel <= 1) then timeWindow = 2.85 
	elseif(difficultyLevel == 2) then timeWindow = 1.95 
	elseif(difficultyLevel == 3) then timeWindow = 1.60
	elseif(difficultyLevel == 4) then timeWindow = 1.35
	end

-- For two player, make it a bit faster
	timeWindow = timeWindow * 0.75;

    local pathPointsLeft = { 
       {160, 240},
       {50, 433}
	}
    local pathPointsCenter = {
        {160, 240},
        {160, 433}
    }
    local pathPointsRight = {
        {160, 240},
        {275,433}
    }
	scaleCurve = { startValue = 0.05, targetValue = 1, curveType = "EaseInQuad" };
	
	function gen2pCurve(colPoints, flip, isX) 
	   local curvePoints = {};
	   local numPoints = #colPoints;
	   local coord;
	   for i=1,numPoints do
	       if isX > 0 then coord = colPoints[i][1] else coord = colPoints[i][2] end
	       if flip > 0 then
	           if isX > 0 then coord = 320 - coord;
	           else coord = 480 - coord;
	           end
	       end
	       curvePoints[i] = {(i - 1) / (numPoints - 1), coord};
	   end
	   return { pathPoints = curvePoints };
	end           
	
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {50,433, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   positionYCurve = gen2pCurve(pathPointsLeft, 0, 0),
	   positionXCurve = gen2pCurve(pathPointsLeft, 0, 1),
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   tapShader = "left_tap", scenePath = "Game/Columns",
	   player = 0, claimedNote = 60, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000 }.colorChangeSpritePath = "Game/Score/Ring1InnerLeft";
	   
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {160, 433, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   positionYCurve = gen2pCurve(pathPointsCenter, 0, 0),
	   positionXCurve = gen2pCurve(pathPointsCenter, 0, 1),
	   tapShader = "middle_tap",  scenePath = "Game/Columns",
	   player = 0, claimedNote = 62, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000}.colorChangeSpritePath = "Game/Score/Ring1InnerMiddle";
	   
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {275, 433, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   positionYCurve = gen2pCurve(pathPointsRight, 0, 0),
	   positionXCurve = gen2pCurve(pathPointsRight, 0, 1),
	   tapShader = "right_tap",  scenePath = "Game/Columns",
	   player = 0, claimedNote = 64, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000 }.colorChangeSpritePath = "Game/Score/Ring1InnerRight";
	
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {320-275,40, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   positionYCurve = gen2pCurve(pathPointsRight, 1, 0),
	   positionXCurve = gen2pCurve(pathPointsRight, 1, 1),
	   tapShader = "right_tap",  scenePath = "Game/Columns",
	   player = 1,  claimedNote = 64, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000, 
	   startRotation = {0, 0, 180}, endRotation = {0, 0, 180} }.colorChangeSpritePath = "Game/Score/Ring2InnerRight";
	   
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {160, 40, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   positionYCurve = gen2pCurve(pathPointsCenter, 1, 0),
	   positionXCurve = gen2pCurve(pathPointsCenter, 1, 1),
	   tapShader = "middle_tap",  scenePath = "Game/Columns",
	   player = 1, claimedNote = 62, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000, 
	   startRotation = {0, 0, 180}, endRotation = {0, 0, 180} }.colorChangeSpritePath = "Game/Score/Ring2InnerMiddle";
	   
	game:addColumn{ 
	   startPosition = {160,240, 0}, 
	   endPosition = {320-50, 40, 0}, 
	   startScale = { 0, 0, 1 }, 
	   endScale = { 1,1,1 }, 
	   timeWindow = timeWindow,
	   scaleXCurve = scaleCurve,
	   scaleYCurve = scaleCurve,
	   positionYCurve = gen2pCurve(pathPointsLeft, 1, 0),
	   positionXCurve = gen2pCurve(pathPointsLeft, 1, 1),
	   tapShader = "left_tap",  scenePath = "Game/Columns",
	   player = 1,  claimedNote = 60, claimedNoteWindowStartTime = 0, claimedNoteWindowDuration = 1000, 
	   startRotation = {0, 0, 180}, endRotation = {0, 0, 180} }.colorChangeSpritePath = "Game/Score/Ring2InnerLeft";
	   
end

-----------------------------------
function theme_initChallengeMode()
    
end

-----------------------------------
function theme_initKidsMode()
    
end

-----------------------------------
function theme_eventPlayerHitTap(playerObject, tapObject, positionArray)
    
end

-----------------------------------
function theme_eventPlayerMissedTap(playerObject)

    if (numberOfLocalPlayers == 1) then
    	game:setFeedbackSettings{
    	   pathColors = backgroundColors
      	};	
	
	enter1x();
	
	end
end

-----------------------------------
function theme_eventPlayerReachedStreakOf10(playerObject)
end

-----------------------------------
function theme_eventPlayerReachedScoreMultiplier(playerObject, newMultiplier)

	game:setFeedbackSettings{
		pathColors = backgroundColors
	};
	
	if (numberOfLocalPlayers == 1) then
		--[[if		(newMultiplier == 1)  then enter1x();
		elseif  (newMultiplier == 2)  then enter2x();
		elseif  (newMultiplier == 3)  then enter3x();
		elseif  (newMultiplier == 4)  then enter4x();]]--
		if		(newMultiplier < 8) then enter4x();
		elseif  (newMultiplier == 8)  then enter8x();
		--elseif  (newMultiplier == 16) then enter16x();
		elseif  (newMultiplier == 16) then enter8x();
		end
	end
	
end

-----------------------------------
function theme_eventPlayerDidChangeLiveRank(playerIndexZeroBased, newRank, rankDelta, tradedPlayerUsername)
    
end

-----------------------------------
function theme_eventPlayerDidReceiveItem(playerIndexZeroBased, itemName, itemDescription, itemQuantity)
    
end

-----------------------------------
function theme_eventPlayerDidDeployItem(playerIndexZeroBased)
    
end

-----------------------------------
function theme_applyItemEffectToPlayer(playerIndexZeroBased, itemName, itemDescription)
    
end

-----------------------------------
function theme_eventAnnounceChallengeWinner(playerIndexZeroBased)
    
end

-----------------------------------
function theme_eventAnnounceTwoPlayerWinner(playerIndexZeroBased)
    
end

-----------------------------------
function theme_eventCompletedGame()
    
end

-----------------------------------
function theme_processTaps(taps)

end

-------------------------------------------------------------------------------------------------------------------
-- OTHER FUNCTIONS
-------------------------------------------------------------------------------------------------------------------

function revengeShaderWithTextureRegions(texFile, normalRegion, revengeRegion, shaderName, sortOrder, blendMode) 
	TTRShader:shaderWithSettings
	{
		name = shaderName,
		sortOrder = sortOrder,	
		passes = 
		{
			{
				texture = { filepath = texFile, region = normalRegion },
				blend = blendMode,
				bindings = {
					property = AlphaProperty,
					input = "revengeModePercentage",
					transformFunction = InverseTransform
			    }
			},
			{
				texture = { filepath = texFile, region = revengeRegion },
				blend = blendMode,
				bindings = {
					property = AlphaProperty,
					input = "revengeModePercentage"
			    }
			}
		}
	}
	return shaderName;
end



function theme_initSpinnerEffectSprite()
if primaryDisableOnSlowDevice == 1 and slowDevice == 1 then
	primarySpinnerMovementType = Disable;
end
if secondDisableOnSlowDevice == 1 and slowDevice == 1 then
	secondSpinnerMovementType = Disable;
end
if thirdDisableOnSlowDevice == 1 and slowDevice == 1 then
	thirdSpinnerMovementType = Disable;
end
if fourthDisableOnSlowDevice == 1 and slowDevice == 1 then
	fourthSpinnerMovementType = Disable;
end
if fifthDisableOnSlowDevice == 1 and slowDevice == 1 then
	fifthSpinnerMovementType = Disable;
end



    if primarySpinnerMovementType == ScaleXY then
    	simpleShaderWithTexture(primaryImage, "discoLight", 2, primarySpinnerBlendMode, "nearest", "nearest");
        discoLight = game:addSprite{
    	   scenePath = layers[primaryLayer + 1],
    	   shader = "discoLight",
    	   alpha = primaryAlphaInitial,
    	   position = {primaryPositionX, primaryPositionY, 0},
    	   scale = {primaryScaleX, primaryScaleY, 1}
    	};
    	discoSpinAnimator = discoLight:addAnimator{
            type='vec3', animatedProperty='scale',
            xCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return primaryAmplitude * math.sin(x*2*math.pi*primaryFrequency + primaryPhase) + primaryOffset end ) },
            yCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return primaryAmplitudeY * math.sin(x*2*math.pi*primaryFrequencyY + primaryPhaseY) + primaryOffsetY end ) },
            duration = 8, loop = 1
        };
    end
    if primarySpinnerMovementType == WashingMachine then
    	simpleShaderWithTexture(primaryImage, "discoLight", 2, primarySpinnerBlendMode, "nearest", "nearest");
        discoLight = game:addSprite{
    	   scenePath = layers[primaryLayer + 1],
    	   shader = "discoLight",
    	   alpha = primaryAlphaInitial,
    	   position = {primaryPositionX, primaryPositionY, 0},
    	   scale = {primaryScaleX, primaryScaleY, 1}
    	};
    	discoSpinAnimator = discoLight:addAnimator{
            type='vec3', animatedProperty='rot',
            zCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return primaryAmplitude * math.sin(x*2*math.pi*primaryFrequency + primaryPhase) + primaryOffset end ) },
            duration = 7, loop = 1
        };
    end
    if primarySpinnerMovementType == AlphaOscillate then
    	simpleShaderWithTexture(primaryImage, "discoLight", 2, primarySpinnerBlendMode, "nearest", "nearest");
        discoLight = game:addSprite{
    	   scenePath = layers[primaryLayer + 1],
    	   shader = "discoLight",
    	   alpha = primaryAlphaInitial,
    	   position = {primaryPositionX, primaryPositionY, 0},
    	   scale = {primaryScaleX, primaryScaleY, 1}
    	};
    	discoSpinAnimator = discoLight:addAnimator{
            type='float', animatedProperty='alpha',
            pathPoints = curveArrayFromLambdaFunction( function (x)
                            return primaryAmplitude * math.sin(x*2*math.pi*primaryFrequency + primaryPhase) + primaryOffset end ),
            duration = 8, loop = 1
        };
    end
    if primarySpinnerMovementType == ScrollRotate then
    	scrollingShaderWithTexture(primaryImage, "discoLight", 2, primarySpinnerBlendMode, primarySpinnerXScrollSpeed, primarySpinnerYScrollSpeed, 1);
        discoLight = game:addSprite{
    	   scenePath = layers[primaryLayer + 1],
    	   shader = "discoLight",
    	   alpha = primaryAlphaInitial,
    	   position = {primaryPositionX, primaryPositionY, 0},
    	   scale = {primaryScaleX, primaryScaleY, 1},
    	   rotationVelocity = {0, 0, primarySpinnerRotationSpeed}
    	};
	end  
	
	    
	    if secondSpinnerMovementType == ScaleXY then
    	simpleShaderWithTexture(secondImage, "discoLight2", 2, secondSpinnerBlendMode, "nearest", "nearest");
        discoLight2 = game:addSprite{
    	   scenePath = layers[secondLayer + 1],
    	   shader = "discoLight2",
    	   alpha = secondAlphaInitial,
    	   position = {secondPositionX, secondPositionY, 0},
    	   scale = {secondScaleX, secondScaleY, 1}
    	};
    	discoSpinAnimator2 = discoLight2:addAnimator{
            type='vec3', animatedProperty='scale',
            xCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return secondAmplitude * math.sin(x*2.0*math.pi*secondFrequency + secondPhase) + secondOffset end ) },
            yCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return secondAmplitudeY * math.sin(x*2.0*math.pi*secondFrequencyY + secondPhaseY) + secondOffsetY end ) },
            duration = 8, loop = 1
        };
		game:log(secondAmplitude);
		game:log(secondFrequency);
		game:log(secondPhase);
		game:log(secondOffset);
		game:log(secondAmplitudeY);
		game:log(secondFrequencyY);
		game:log(secondPhaseY);
		game:log(secondOffsetY);

    end
    if secondSpinnerMovementType == WashingMachine then
    	simpleShaderWithTexture(secondImage, "discoLight2", 2, secondSpinnerBlendMode, "nearest", "nearest");
        discoLight2 = game:addSprite{
    	   scenePath = layers[secondLayer + 1],
    	   shader = "discoLight2",
    	   alpha = secondAlphaInitial,
    	   position = {secondPositionX, secondPositionY, 0},
    	   scale = {secondScaleX, secondScaleY, 1}
    	};
    	discoSpinAnimator2 = discoLight2:addAnimator{
            type='vec3', animatedProperty='rot',
            zCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return secondAmplitude * math.sin(x*2*math.pi*secondFrequency + secondPhase) + secondOffset end ) },
            duration = 7, loop = 1
        };
    end
    if secondSpinnerMovementType == AlphaOscillate then
    	simpleShaderWithTexture(secondImage, "discoLight2", 2, secondSpinnerBlendMode, "nearest", "nearest");
        discoLight2 = game:addSprite{
    	   scenePath = layers[secondLayer + 1],
    	   shader = "discoLight2",
    	   alpha = secondAlphaInitial,
    	   position = {secondPositionX, secondPositionY, 0},
    	   scale = {secondScaleX, secondScaleY, 1}
    	};
    	discoSpinAnimator2 = discoLight2:addAnimator{
            type='float', animatedProperty='alpha',
            pathPoints = curveArrayFromLambdaFunction( function (x)
                            return secondAmplitude * math.sin(x*2*math.pi*secondFrequency + secondPhase) + secondOffset end ),
            duration = 8, loop = 1
        };
    end
    if secondSpinnerMovementType == ScrollRotate then
    	scrollingShaderWithTexture(secondImage, "discoLight2", 2, secondSpinnerBlendMode, secondSpinnerXScrollSpeed, secondSpinnerYScrollSpeed, 1);
        discoLight2 = game:addSprite{
    	   scenePath = layers[secondLayer + 1],
    	   shader = "discoLight2",
    	   alpha = secondAlphaInitial,
    	   position = {secondPositionX, secondPositionY, 0},
    	   scale = {secondScaleX, secondScaleY, 1},
    	   rotationVelocity = {0, 0, secondSpinnerRotationSpeed}
    	};
	end  
	-----------------
	    if thirdSpinnerMovementType == ScaleXY then
    	simpleShaderWithTexture(thirdImage, "discoLight3", 2, thirdSpinnerBlendMode, "nearest", "nearest");
        discoLight3 = game:addSprite{
    	   scenePath = layers[thirdLayer + 1],
    	   shader = "discoLight3",
    	   alpha = thirdAlphaInitial,
    	   position = {thirdPositionX, thirdPositionY, 0},
    	   scale = {thirdScaleX, thirdScaleY, 1}
    	};
    	discoSpinAnimator3 = discoLight3:addAnimator{
            type='vec3', animatedProperty='scale',
            xCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return thirdAmplitude * math.sin(x*2*math.pi*thirdFrequency + thirdPhase) + thirdOffset end ) },
            yCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return thirdAmplitudeY * math.sin(x*2*math.pi*thirdFrequencyY + thirdPhaseY) + thirdOffsetY end ) },
            duration = 8, loop = 1
        };
    end
    if thirdSpinnerMovementType == WashingMachine then
    	simpleShaderWithTexture(thirdImage, "discoLight3", 2, thirdSpinnerBlendMode, "nearest", "nearest");
        discoLight3 = game:addSprite{
    	   scenePath = layers[thirdLayer + 1],
    	   shader = "discoLight3",
    	   alpha = thirdAlphaInitial,
    	   position = {thirdPositionX, thirdPositionY, 0},
    	   scale = {thirdScaleX, thirdScaleY, 1}
    	};
    	discoSpinAnimator3 = discoLight3:addAnimator{
            type='vec3', animatedProperty='rot',
            zCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return 10 * thirdAmplitude * math.sin(x*2*math.pi*thirdFrequency + thirdPhase) + thirdOffset end ) },
            duration = 7, loop = 1
        };
    end
    if thirdSpinnerMovementType == AlphaOscillate then
    	simpleShaderWithTexture(thirdImage, "discoLight3", 2, thirdSpinnerBlendMode, "nearest", "nearest");
        discoLight3 = game:addSprite{
    	   scenePath = layers[thirdLayer + 1],
    	   shader = "discoLight3",
    	   alpha = thirdAlphaInitial,
    	   position = {thirdPositionX, thirdPositionY, 0},
    	   scale = {thirdScaleX, thirdScaleY, 1}
    	};
    	discoSpinAnimator3 = discoLight3:addAnimator{
            type='float', animatedProperty='alpha',
            pathPoints = curveArrayFromLambdaFunction( function (x)
                            return 0.5 * thirdAmplitude * math.sin(x*2*math.pi*thirdFrequency + thirdPhase) + thirdOffset end ),
            duration = 8, loop = 1
        };
    end
    if thirdSpinnerMovementType == ScrollRotate then
    	scrollingShaderWithTexture(thirdImage, "discoLight3", 2, thirdSpinnerBlendMode, thirdSpinnerXScrollSpeed, thirdSpinnerYScrollSpeed, 1);
        discoLight3 = game:addSprite{
    	   scenePath = layers[thirdLayer + 1],
    	   shader = "discoLight3",
    	   alpha = thirdAlphaInitial,
    	   position = {thirdPositionX, thirdPositionY, 0},
    	   scale = {thirdScaleX, thirdScaleY, 1},
    	   rotationVelocity = {0, 0, thirdSpinnerRotationSpeed}
    	};
	end  
	---------------------------------
	
	    if fourthSpinnerMovementType == ScaleXY then
    	simpleShaderWithTexture(fourthImage, "discoLight4", 2, fourthSpinnerBlendMode, "nearest", "nearest");
        discoLight4 = game:addSprite{
    	   scenePath = layers[fourthLayer + 1],
    	   shader = "discoLight4",
    	   alpha = fourthAlphaInitial,
    	   position = {fourthPositionX, fourthPositionY, 0},
    	   scale = {fourthScaleX, fourthScaleY, 1}
    	};
    	discoSpinAnimator4 = discoLight4:addAnimator{
            type='vec3', animatedProperty='scale',
            xCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return fourthAmplitude * math.sin(x*2*math.pi*fourthFrequency + fourthPhase) + fourthOffset end ) },
            yCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return fourthAmplitudeY * math.sin(x*2*math.pi*fourthFrequencyY + fourthPhaseY) + fourthOffsetY end ) },
            duration = 8, loop = 1
        };
    end
    if fourthSpinnerMovementType == WashingMachine then
    	simpleShaderWithTexture(fourthImage, "discoLight4", 2, fourthSpinnerBlendMode, "nearest", "nearest");
        discoLight4 = game:addSprite{
    	   scenePath = layers[fourthLayer + 1],
    	   shader = "discoLight4",
    	   alpha = fourthAlphaInitial,
    	   position = {fourthPositionX, fourthPositionY, 0},
    	   scale = {fourthScaleX, fourthScaleY, 1}
    	};
    	discoSpinAnimator4 = discoLight4:addAnimator{
            type='vec3', animatedProperty='rot',
            zCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return 10 * fourthAmplitude * math.sin(x*2*math.pi*fourthFrequency + fourthPhase) + fourthOffset end ) },
            duration = 7, loop = 1
        };
    end
    if fourthSpinnerMovementType == AlphaOscillate then
    	simpleShaderWithTexture(fourthImage, "discoLight4", 2, fourthSpinnerBlendMode, "nearest", "nearest");
        discoLight4 = game:addSprite{
    	   scenePath = layers[fourthLayer + 1],
    	   shader = "discoLight4",
    	   alpha = fourthAlphaInitial,
    	   position = {fourthPositionX, fourthPositionY, 0},
    	   scale = {fourthScaleX, fourthScaleY, 1}
    	};
    	discoSpinAnimator4 = discoLight4:addAnimator{
            type='float', animatedProperty='alpha',
            pathPoints = curveArrayFromLambdaFunction( function (x)
                            return 0.5 * fourthAmplitude * math.sin(x*2*math.pi*fourthFrequency + fourthPhase) + fourthOffset end ),
            duration = 8, loop = 1
        };
    end
    if fourthSpinnerMovementType == ScrollRotate then
    	scrollingShaderWithTexture(fourthImage, "discoLight4", 2, fourthSpinnerBlendMode, fourthSpinnerXScrollSpeed, fourthSpinnerYScrollSpeed, 1);
        discoLight4 = game:addSprite{
    	   scenePath = layers[fourthLayer + 1],
    	   shader = "discoLight4",
    	   alpha = fourthAlphaInitial,
    	   position = {fourthPositionX, fourthPositionY, 0},
    	   scale = {fourthScaleX, fourthScaleY, 1},
    	   rotationVelocity = {0, 0, fourthSpinnerRotationSpeed}
    	};
	end  
	-------------
	
	    if fifthSpinnerMovementType == ScaleXY then
    	simpleShaderWithTexture(fifthImage, "discoLight5", 2, fifthSpinnerBlendMode, "nearest", "nearest");
        discoLight5 = game:addSprite{
    	   scenePath = layers[fifthLayer + 1],
    	   shader = "discoLight5",
    	   alpha = fifthAlphaInitial,
    	   position = {fifthPositionX, fifthPositionY, 0},
    	   scale = {fifthScaleX, fifthScaleY, 1}
    	};
    	discoSpinAnimator5 = discoLight5:addAnimator{
            type='vec3', animatedProperty='scale',
            xCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return fifthAmplitude * math.sin(x*2*math.pi*fifthFrequency + fifthPhase) + fifthOffset end ) },
            yCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return fifthAmplitudeY * math.sin(x*2*math.pi*fifthFrequencyY + fifthPhaseY) + fifthOffsetY end ) },
            duration = 8, loop = 1
        };
    end
    if fifthSpinnerMovementType == WashingMachine then
    	simpleShaderWithTexture(fifthImage, "discoLight5", 2, fifthSpinnerBlendMode, "nearest", "nearest");
        discoLight5 = game:addSprite{
    	   scenePath = layers[fifthLayer + 1],
    	   shader = "discoLight5",
    	   alpha = fifthAlphaInitial,
    	   position = {fifthPositionX, fifthPositionY, 0},
    	   scale = {fifthScaleX, pfifthScaleY, 1}
    	};
    	discoSpinAnimator5 = discoLight5:addAnimator{
            type='vec3', animatedProperty='rot',
            zCurve = { pathPoints = curveArrayFromLambdaFunction( function (x)
                            return fifthAmplitude * math.sin(x*2*math.pi*fifthFrequency + fifthPhase) + fifthOffset end ) },
            duration = 7, loop = 1
        };
    end
    if fifthSpinnerMovementType == AlphaOscillate then
    	simpleShaderWithTexture(fifthImage, "discoLight5", 2, fifthSpinnerBlendMode, "nearest", "nearest");
        discoLight5 = game:addSprite{
    	   scenePath = layers[fifthLayer + 1],
    	   shader = "discoLight5",
    	   alpha = fifthAlphaInitial,
    	   position = {fifthPositionX, fifthPositionY, 0},
    	   scale = {fifthScaleX, fifthScaleY, 1}
    	};
    	discoSpinAnimator5 = discoLight5:addAnimator{
            type='float', animatedProperty='alpha',
            pathPoints = curveArrayFromLambdaFunction( function (x)
                            return 0.5 * fifthAmplitude * math.sin(x*2*math.pi*fifthFrequency + fifthPhase) + fifthOffset end ),
            duration = 8, loop = 1
        };
    end
    if fifthSpinnerMovementType == ScrollRotate then
    	scrollingShaderWithTexture(fifthImage, "discoLight5", 2, fifthSpinnerBlendMode, fifthSpinnerXScrollSpeed, fifthSpinnerYScrollSpeed, 1);
        discoLight5 = game:addSprite{
    	   scenePath = layers[fifthLayer + 1],
    	   shader = "discoLight5",
    	   alpha = fifthAlphaInitial,
    	   position = {fifthPositionX, fifthPositionY, 0},
    	   scale = {fifthScaleX, fifthScaleY, 1},
    	   rotationVelocity = {0, 0, fifthSpinnerRotationSpeed}
    	};
	end  
end

function fadeSprite2(sprite, alpha, dur) 
	if ( degradedGraphics and dur > 0.05 ) or ( game.gameController.currentFrameRate < 16 ) then
		dur = 0.05;
	end
	
	sprite.visible = 1;
	
	sprite:addAnimator{
		type = "float",
		animatedProperty = "alpha",
		duration = dur,
		targetValue = alpha
	};
end

function scaleSprite(sprite, size, dur)
	sprite:addVec3Animator{
		animatedProperty = "scale", targetVector = size,
		duration = dur, xCurve = { curveType = "EaseInSin" }
	};
end

-- INTRO FADEIN

function fadeInIntro()
	game:addSprite {
		scenePath = "Game/FeedbackLayer", shader = "fadeIn",
		position = {160, 240, 0}, size = {322, 482, 0},
		lifetime = 1.4, alpha = 1,
		spawnTime = game.lastFrameTime,
	}.endOfLifeFadeoutTime = 1.25
	
	--Fadeout here
	game:addSprite {
		scenePath = "Game/Columns2", shader = "fadeIn",
		position = {160, 240, 0}, size = {322, 482, 0},
		lifetime = 5, alpha = 0, alphaVelocity = 0.27,
		spawnTime = game.audioPlayer.playbackTotal - 2.5,
	}.endOfLifeFadeoutTime = 2.5
	
end

-- CONSTANT PARTICLE EFFECTS

function addParticles()

	timeout = 1.5;
	spaceAura = spaceAura + 1;
	
	--MAKE AN AWESOME COMET
	
	if(math.random(1, 7) < 5 and eight < 2 and 1==2) then
		local randomSize = math.random(4, 8) / 10;
		local randomXLoc = math.random(-100, 420);
		game:addSprite {
			scenePath = "Game/Background",
			position = {randomXLoc, 350 - math.abs(randomXLoc-160)*20/260, 0},
			scale = {randomSize, randomSize, 0},
			scaleVelocity = {randomSize/-2, randomSize/-2, 0},
			rotation = {0, 0, (randomXLoc-160)/(-16) * 3 + 90},
			spawnTime = game.lastFrameTime,
			alpha = 1,
			lifetime = 2,
			velocity = {(randomXLoc-160) / -2.5, -190 + math.random(-10, 10) + math.abs(randomXLoc-160)*20/260, 0},
			acceleration = {0, 40, 0},
			shader = "comet",
		}.endOfLifeFadeoutTime = 1.65
	end

	if(eight == 0 and spaceAura == 1) then -- IF REGULAR MODE
		game:addSprite {
			scenePath = "Game/Background",
			position = {160 + math.random(200)-100, 150 + math.random(80)-40, 0},
			scale = {0.85, 0.85, 1},
			scaleVelocity = {.10, .065, 0},
			scaleAcceleration = {.05, .05, 0},
			rotation = {0, 0, math.random(360)},
			rotationVelocity = {0, 0, math.random(14)-7},
			spawnTime = game.lastFrameTime,
			alpha = 0.0,
			alphaVelocity = 0.8,
			lifetime = 4.4,
			velocity = {math.random(-7, 7), math.random(3, 12), 0},
			shader = "spaceParticles"..math.random(1, 2),
		}.endOfLifeFadeoutTime = .75
		
	elseif(eight == 0 and spaceAura >= 2) then
		spaceAura = 0;
	
	elseif(eight == 1) then -- IF 8X MODE
		timeout = 1.5;
		game:addSprite {
			scenePath = "Game/Background",
			position = {160, 115, 0},
			scale = {0.2, 0.2, 1},
			scaleVelocity = {.55, .5, 0},
			scaleAcceleration = {.5, .5, 0},
			spawnTime = game.lastFrameTime,
			alpha = 0.0,
			alphaVelocity = 0.8,
			lifetime = 2.3,
			velocity = {0, -30, 0},
			shader = "triangles"
		}.endOfLifeFadeoutTime = 1.0
		
--[[		if(spaceAura >= 2) then
			game:addSprite {
				scenePath = "Game/Background0",
				position = {160, 120, 0},
				scale = {0.40, 0.40, 1},
				spawnTime = game.lastFrameTime,
				scaleVelocity = {1.250, 1.25, 0}, scaleAcceleration = {1.8, 1.8, 0},
				alpha = 0.0, alphaVelocity = 2,
				rotationVelocity = {0, 0, -60}, rotationAcceleration = {0, 0, -68},
				lifetime = 1.5,
				shader = "revBurst"
			}.endOfLifeFadeoutTime = 0.45
			spaceAura = 0;
		end]]--
	
	else -- IF 16X MODE

	end
    setTimeout(timeout, "addParticles", nil);
end


-- VARIOUS MULTIPLIER MODES ED HAS A FACE

function enter1x()
	
	hide8x();
			
	fadeSprite2(discoLight, 1, .35);
	if(eight > 0) then
		scaleSprite(discoLight, {1.25, 1.25, 1}, 0);
	else
		scaleSprite(discoLight, {1.25, 1.25, 1}, 0.95);
	end
	
	fadeSprite2(discoLight2, 0.0, .35);
	scaleSprite(discoLight2, {0, 0, 1}, 0.0);
	
	fadeSprite2(discoLight3, .65, .35);
	scaleSprite(discoLight3, {.85, .85, 1}, 0.0);
	
	fadeSprite2(Atmosphere, 0.0, .35)
	
	--if(eight == 2) then
	--	hide16x();
	--end
	
	eight = 0;
	
end

function enter2x()
			
	fadeSprite2(discoLight, 0.7, .5);
	scaleSprite(discoLight, {1.12, 1.12, 1}, 0.75);
	
	fadeSprite2(discoLight3, .8, .35);
	scaleSprite(discoLight3, {.98, .98, 1}, 0.95);
	
	fadeSprite2(Atmosphere, 0.30, .35)
	
	--if(eight == 2) then
	--	hide16x();
	--end
	
	eight = 0;

end

function enter3x()

	fadeSprite2(discoLight, 0.4, .5);
	scaleSprite(discoLight, {1, 1, 1}, 0.75);
	
	fadeSprite2(discoLight3, 1, .35);
	scaleSprite(discoLight3, {1.25, 1.25, 1}, 0.95);
	
	fadeSprite2(Atmosphere, 0.70, .35)
	
	if(eight == 2) then
		hide16x();
	end
	
	eight = 0;

end

function enter4x()

	--scaleSprite(discoLight, {0.9375, 0.9375, 1}, 0.75);
	
	--scaleSprite(discoLight3, {1.55, 1.55, 1}, 0.95);
	
	fadeSprite2(Atmosphere, 1, .35)
	
	--if(eight == 2) then
	--	hide16x();
	--end
	
	eight = 0;

end

function enter8x()

	--[[game:addSprite {
		scenePath = "Game/Background0",
		position = {160, 120, 0},
		scale = {0.40, 0.40, 1},
		spawnTime = game.lastFrameTime,
		scaleVelocity = {.80, .80, 0}, scaleAcceleration = {1.3, 1.3, 0},
		alpha = 0.0, alphaVelocity = 0.8,
		rotationVelocity = {0, 0, -30}, rotationAcceleration = {0, 0, -18},
		lifetime = 2.2,
		shader = "revBurst"
	}.endOfLifeFadeoutTime = 0.75]]--
	
	fadeSprite2(WavesR, 1, .55);
	fadeSprite2(WavesL, 1, .55);
			
	fadeSprite2(discoLight, 0.0, .75);
	scaleSprite(discoLight, {0.01, 0.01, 1}, 0);
	
	fadeSprite2(discoLight2, 1, .35);
	scaleSprite(discoLight2, {1, 1, 1}, 0.0);
	
	fadeSprite2(Atmosphere, .5, .35)
	
	scaleSprite(discoLight3, {.85, .85, 1}, 1.5);
	
	--if(eight == 2) then
	--	hide16x();
	--end

	eight = 1;

end

--[[function enter16x()

	hide8x();
	hideNormal();
	
	scaleSprite(corridorTop, {1.5, 1.2, 1}, 0);
	scaleSprite(corridorBottom, {1.67, 1.55, 1}, 0);
	scaleSprite(revengeWave, {1, .75, 1}, 0);
	scaleSprite(zoomTop, {1.5, 1.2, 1}, 0);
	scaleSprite(zoomBottom, {1.67, 1.55, 1}, 0);
	fadeSprite2(corridorTop, 1, 1.5);
	fadeSprite2(corridorBottom, 1, 1.5);
	fadeSprite2(zoomTop, 1, 1.5);
	fadeSprite2(zoomBottom, 1, 1.5);
	fadeSprite2(revengeWave, 1, 1.5);
	eight = 2;
end]]--

function hideNormal()
	fadeSprite2(discoLight2, 0.0, .35);
	scaleSprite(discoLight2, {0, 0, 1}, 0.0);
	
	fadeSprite2(discoLight3, 0.0, .35);
	scaleSprite(discoLight3, {0, 0, 1}, 0.0);
	
	fadeSprite2(Atmosphere, 0.5, .35)
end

--[[function hide16x()

	fadeSprite2(corridorTop, 0, 1.0);
	fadeSprite2(corridorBottom, 0, 1.0);
	fadeSprite2(revengeWave, 0, 1.5);
	fadeSprite2(zoomTop, 0, 1.5);
	fadeSprite2(zoomBottom, 0, 1.5);
	setTimeout(5.5, "shrinkRevenge", nil);

end]]--

function hide8x()
	
	fadeSprite2(WavesR, 0.0, .55);
	fadeSprite2(WavesL, 0.0, .55);
	
	fadeSprite2(discoLight2, 0.0, .35);
	scaleSprite(discoLight2, {.01, .01, 1}, 0.0);

end

function shrinkRevenge()
	scaleSprite(corridorTop, {0.01, 0.01, 1}, 0);
	scaleSprite(corridorBottom, {0.01, 0.01, 1}, 0);
	scaleSprite(revengeWave, {0.01, 0.01, 1}, 0);
	scaleSprite(zoomTop, {0.01, 0.01, 1}, 0);
	scaleSprite(zoomBottom, {0.01, 0.01, 1}, 0);
end
